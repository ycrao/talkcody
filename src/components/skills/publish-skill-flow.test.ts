/**
 * Test for publish skill flow - ensures slug consistency between R2 and database
 */

import { beforeEach, describe, expect, it, vi } from 'vitest';
import { validate as isValidUuid } from 'uuid';

describe('Publish Skill Flow - Slug Consistency', () => {
  let mockApiClient: any;
  let mockR2Storage: any;
  let mockMarketplaceService: any;

  beforeEach(() => {
    // Mock API client
    mockApiClient = {
      post: vi.fn(),
      patch: vi.fn(),
    };

    // Mock R2 storage service
    mockR2Storage = {
      setAuthToken: vi.fn(),
      uploadSkillPackage: vi.fn(),
    };

    // Mock marketplace service
    mockMarketplaceService = {
      publishSkill: vi.fn(),
    };
  });

  it('should create skill in database first and use returned slug for R2 upload', async () => {
    // Arrange
    const skillName = 'Check Chinese Characters';
    const expectedSlug = 'check-chinese-characters'; // Generated by API from name
    const fileBasedSkillId = 'check-chinese-local-001'; // File system directory name

    // Mock API response - returns generated slug
    mockApiClient.post.mockResolvedValueOnce({
      ok: true,
      json: async () => ({
        skill: {
          id: 'uuid-123',
          slug: expectedSlug,
          name: skillName,
        },
      }),
    });

    // Mock marketplace service upload
    mockMarketplaceService.publishSkill.mockResolvedValueOnce({
      success: true,
      storageUrl: `https://cdn.talkcody.com/skills/${expectedSlug}/1.0.0/package.tar.gz`,
      metadata: {
        packageSize: 1024,
        checksum: 'abc123',
      },
    });

    // Mock PATCH request
    mockApiClient.patch.mockResolvedValueOnce({
      ok: true,
      json: async () => ({ skill: {} }),
    });

    // Mock publish request
    mockApiClient.post.mockResolvedValueOnce({
      ok: true,
      json: async () => ({ skill: {} }),
    });

    // Act - Simulate the publish flow
    // Step 1: Create skill in database
    const createResponse = await mockApiClient.post('/api/skills', {
      name: skillName,
      description: 'Test description',
    });
    const createData = await createResponse.json();
    const skillSlug = createData.skill.slug;

    // Step 2: Upload to R2 with slug
    await mockMarketplaceService.publishSkill({
      skill: { id: fileBasedSkillId, name: skillName },
      slug: skillSlug, // Use slug from database
    });

    // Assert
    expect(skillSlug).toBe(expectedSlug);
    expect(mockMarketplaceService.publishSkill).toHaveBeenCalledWith(
      expect.objectContaining({
        slug: expectedSlug, // Ensure slug is passed to publish
      })
    );
  });

  it('should ensure R2 path matches database slug', async () => {
    // This test verifies the bug is fixed:
    // Before fix: R2 path used file system ID (check-chinese-local-001)
    // After fix: R2 path uses database slug (check-chinese-characters)

    const skillName = 'My Test Skill';
    const databaseSlug = 'my-test-skill'; // Generated by API
    const fileSystemId = 'my-test-skill-local-123'; // Different from slug

    // Mock API to return slug
    mockApiClient.post.mockResolvedValueOnce({
      ok: true,
      json: async () => ({
        skill: {
          id: 'uuid-456',
          slug: databaseSlug,
        },
      }),
    });

    // Mock upload function
    mockR2Storage.uploadSkillPackage.mockImplementation(
      (skillId: string, version: string) => {
        // skillId should be the slug, not the file system ID
        return Promise.resolve({
          key: `skills/${skillId}/${version}/package.tar.gz`,
          url: `https://cdn.talkcody.com/skills/${skillId}/${version}/package.tar.gz`,
        });
      }
    );

    // Simulate publish
    const createResponse = await mockApiClient.post('/api/skills', { name: skillName });
    const createData = await createResponse.json();
    const slug = createData.skill.slug;

    // Upload using slug
    const uploadResult = await mockR2Storage.uploadSkillPackage(slug, '1.0.0');

    // Assert: R2 path should use database slug, not file system ID
    expect(uploadResult.key).toBe(`skills/${databaseSlug}/1.0.0/package.tar.gz`);
    expect(uploadResult.key).not.toContain(fileSystemId);
    expect(mockR2Storage.uploadSkillPackage).toHaveBeenCalledWith(
      databaseSlug, // Should use slug from database
      '1.0.0'
    );
  });

  it('should fail gracefully if slug is not returned from API', async () => {
    // Mock API response without slug
    mockApiClient.post.mockResolvedValueOnce({
      ok: true,
      json: async () => ({
        skill: {
          id: 'uuid-789',
          // slug is missing!
          name: 'Test Skill',
        },
      }),
    });

    // Simulate publish flow
    const createResponse = await mockApiClient.post('/api/skills', {
      name: 'Test Skill',
    });
    const createData = await createResponse.json();
    const skillSlug = createData.skill.slug;

    // Assert: Should detect missing slug
    expect(skillSlug).toBeUndefined();

    // In real code, this should throw an error:
    // if (!skillSlug) throw new Error('Failed to get skill slug from API');
  });

  it('should use slug for both database and R2 download paths', async () => {
    const slug = 'test-skill-slug';

    // When installing, the download should use the slug
    const downloadPath = `/api/skills/packages/${slug}/1.0.0/download`;
    const r2Path = `skills/${slug}/1.0.0/package.tar.gz`;

    // Assert paths match
    expect(downloadPath).toContain(slug);
    expect(r2Path).toContain(slug);
    expect(downloadPath.split('/')[4]).toBe(slug); // Extract slug from path
  });
});

describe('Publish Skill Metadata', () => {
  it('should not include email in published metadata', () => {
    // Arrange
    const user = {
      name: 'testuser',
      displayName: 'Test User',
      email: 'test@example.com',
    };

    // Act - Create author metadata without email
    const authorMetadata = {
      name: user.displayName || user.name || 'Anonymous',
      // email should NOT be included
    };

    // Assert
    expect(authorMetadata).toHaveProperty('name');
    expect(authorMetadata).not.toHaveProperty('email');
    expect(authorMetadata.name).toBe('Test User');
  });

  it('should use displayName when available', () => {
    // Arrange
    const userWithDisplayName = {
      name: 'johndoe',
      displayName: 'John Doe',
      email: 'john@example.com',
    };

    // Act
    const authorName = userWithDisplayName.displayName || userWithDisplayName.name || 'Anonymous';

    // Assert
    expect(authorName).toBe('John Doe');
  });

  it('should fallback to name when displayName is not available', () => {
    // Arrange
    const userWithoutDisplayName = {
      name: 'janedoe',
      email: 'jane@example.com',
    };

    // Act
    const authorName =
      userWithoutDisplayName.displayName || userWithoutDisplayName.name || 'Anonymous';

    // Assert
    expect(authorName).toBe('janedoe');
  });

  it('should fallback to Anonymous when neither displayName nor name is available', () => {
    // Arrange
    const userWithoutNameFields = {
      email: 'anonymous@example.com',
    };

    // Act
    const authorName =
      userWithoutNameFields.displayName || userWithoutNameFields.name || 'Anonymous';

    // Assert
    expect(authorName).toBe('Anonymous');
  });
});

describe('Skill ID UUID Validation', () => {
  it('should validate UUID format correctly', () => {
    // Valid UUIDs
    expect(isValidUuid('550e8400-e29b-41d4-a716-446655440000')).toBe(true);
    expect(isValidUuid('6ba7b810-9dad-11d1-80b4-00c04fd430c8')).toBe(true);

    // Invalid formats
    expect(isValidUuid('check-chinese-local-001')).toBe(false);
    expect(isValidUuid('not-a-uuid')).toBe(false);
    expect(isValidUuid('123456')).toBe(false);
    expect(isValidUuid('')).toBe(false);
  });

  it('should regenerate skillId when invalid UUID format is detected', async () => {
    // Arrange
    const mockFileSkillService = {
      getSkillById: vi.fn(),
      updateSkill: vi.fn(),
    };

    const invalidSkillId = 'check-chinese-local-001';
    const fileBasedSkillWithInvalidId = {
      id: invalidSkillId,
      name: 'Check Chinese',
      metadata: {
        skillId: invalidSkillId,
      },
      content: {},
      frontmatter: {},
      localPath: '/path/to/skill',
    };

    mockFileSkillService.getSkillById.mockResolvedValueOnce(fileBasedSkillWithInvalidId);

    // Act - Simulate UUID validation and regeneration
    let skill = fileBasedSkillWithInvalidId;

    if (!isValidUuid(skill.id)) {
      // This simulates what the publish dialog does
      const oldId = skill.id;
      const newId = '550e8400-e29b-41d4-a716-446655440000'; // Mock UUID

      skill.id = newId;
      skill.metadata.skillId = newId;
      await mockFileSkillService.updateSkill(skill);

      // Simulate reload
      mockFileSkillService.getSkillById.mockResolvedValueOnce({
        ...skill,
        id: newId,
        metadata: { ...skill.metadata, skillId: newId },
      });

      skill = await mockFileSkillService.getSkillById(newId);
    }

    // Assert
    expect(skill.id).not.toBe(invalidSkillId);
    expect(isValidUuid(skill.id)).toBe(true);
    expect(skill.metadata.skillId).toBe(skill.id);
    expect(mockFileSkillService.updateSkill).toHaveBeenCalledWith(
      expect.objectContaining({
        id: expect.stringMatching(
          /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/
        ),
      })
    );
  });

  it('should not regenerate skillId when it is already a valid UUID', async () => {
    // Arrange
    const validUuid = '550e8400-e29b-41d4-a716-446655440000';
    const mockFileSkillService = {
      updateSkill: vi.fn(),
    };

    const fileBasedSkillWithValidId = {
      id: validUuid,
      metadata: {
        skillId: validUuid,
      },
    };

    // Act - Check if UUID is valid
    const needsRegeneration = !isValidUuid(fileBasedSkillWithValidId.id);

    if (needsRegeneration) {
      await mockFileSkillService.updateSkill(fileBasedSkillWithValidId);
    }

    // Assert - Should NOT call updateSkill
    expect(needsRegeneration).toBe(false);
    expect(mockFileSkillService.updateSkill).not.toHaveBeenCalled();
  });

  it('should ensure skillId in metadata matches the skill id after regeneration', async () => {
    // Arrange
    const mockFileSkillService = {
      updateSkill: vi.fn(),
      getSkillById: vi.fn(),
    };

    const skill = {
      id: 'invalid-id-123',
      metadata: {
        skillId: 'invalid-id-123',
      },
    };

    // Act
    if (!isValidUuid(skill.id)) {
      const newId = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
      skill.id = newId;
      skill.metadata.skillId = newId;
      await mockFileSkillService.updateSkill(skill);
    }

    // Assert
    expect(skill.id).toBe(skill.metadata.skillId);
    expect(isValidUuid(skill.id)).toBe(true);
    expect(isValidUuid(skill.metadata.skillId)).toBe(true);
  });
});
